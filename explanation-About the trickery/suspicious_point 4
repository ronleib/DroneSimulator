הוסיפו לסימולציה יכולת מיפוי חכמה משמע לחזור ולהגלות נקודות חשודות שלא ביקרתם שם. במילים אחרות במקום לחזור הביתה נחזור לנקודה החשודה הקרובה. ולאחר שנבקר בה נשמיט אותה מרשימת הנקודות החשודות.

שמרנו את כול הנקודות באש מאף

ממש אותו דבר כימת כמו לחזור הביתה רק לחזור לנקודה החשודה האחרונה שנשמרה
 	public  Thread suspicious_point= new Thread() {
		public void run(){
			System.out.println(ai_cpu.isPlay);System.out.println("ggggg");
			if (ran2 != null) {
				List<node_data> arr = grap.shortestPath(Last_suspicious_point.getKey(), ran.getKey());
				connectedNodesuspicious = arr.iterator();
				System.out.println(arr.size());
				ran2 = null;
				ran_return_home = (node_data) connectedNodesuspicious.next();
				while (isRotating==1) {// imitate to open
				}
				spinBy(finalSpin_by - 180);
				time=System.currentTimeMillis()+300;
			}
			if (connectedNodesuspicious.hasNext()) {
				if (ran_return_home.getTimeold() <= System.currentTimeMillis()-time) {
					if (Tools.getDistanceBetweenPoints(ran_return_home.getLocation(),drone.getOpticalSensorLocation())<max_distance_between_points/5){
						System.out.println("ID NEW NODE"+ran_return_home.getKey());
						ran_return_home = (node_data) connectedNodesuspicious.next();
						System.out.println("getWeight"+ran.getWeight());
						while (isRotating==1) {// imitate to open
						}
						spinBy(ran.getWeight());
						time=System.currentTimeMillis();
					}
					if (ran_return_home.getKey() == 1)
						spinBy(ran.getWeight()-180);
					SimulationWindow.suspicious_point=!SimulationWindow.suspicious_point;
					important_point.remove(ran_return_home.getKey());

				}
			}
		}
	};
