הוסיפו לסימולציה יכולת "חזרה הביתה" - למשל ע"י לחיצה על כפתור R או כאשר הרחפן מגיע ל 50 %


היכולת פועלת כך שהוא לוכך את הנקודה התחלתית ואת הנקודה ההחרונה שנשמרה במאגר ומפיל אלה את הפנקציה shortestPath כך שיוצר לנו מסלול חזרה 
הוא חוזר בזרת הצוויות ששמרנו לנו בכול נקודה הוא משנה אותם כול עוד לא עבר אורך הזמן +100 מאורך הזמן שנשמר בנקודה ושמרחק מרחפן לנקודה לא גדול מי 100 
ועדין שומר על אלגריתם הגנה שלו לא לכנס בקירות 


*נשהוא לכניש אותו לThread משלו איך יש בעיה גדולה בקוד עם הThread ולכן לא הכנסתו אותו לThread מי שלו 

		if (SimulationWindow.return_home) {

			if (connectedNode==null) {
				System.out.println("new connectedNode" );
				List<node_data> arr = grap.shortestPath(1, ran.getKey());
				connectedNode = arr.iterator();
				System.out.println(arr.size());
				ran_return_home = (node_data) connectedNode.next();
				time=System.currentTimeMillis();
				this.speedUp();
			}
			else if (connectedNode.hasNext() && ran_return_home.getLocation().distance2D(ran_return_home.getLocation(),ran.getLocation())<100 &&
					ran_return_home.getTimeold()<System.currentTimeMillis()-time) {
//				if (ran_return_home.getLocation().distance2D(ran_return_home.getLocation(),ran.getLocation())<50 ) {
					System.out.println("ran_return_home.getTimeold() "+ran_return_home.getTimeold()+"/n"+(System.currentTimeMillis()-time));
							ran_return_home = (node_data) connectedNode.next();
							System.out.println("ran_return_home=" + ran_return_home.getKey());
					System.out.println("ran_return_home=" + ran_return_home.getWeight());
							time=System.currentTimeMillis();
//						while (isRotating==1) {// imitate to open
//						}
//							spinBy((ran_return_home.getWeight()),true);
					if (ran_return_home.getKey() == 1) drone.stop();
			}
		}

